package main

import (
	"context"
	"database/sql"
	"fmt"
	"io"
	"os"
	"path/filepath"

	_ "github.com/mattn/go-sqlite3"
	"github.com/wilgaboury/wusic/protos"
)

var Db *sql.DB

func InitDb() {
	err := os.MkdirAll(filepath.Join(Params.DbDir, "songs"), os.ModePerm)
	CheckErrFatal(err)

	f, err := os.OpenFile(filepath.Join(Params.DbDir, "db.sqlite"), os.O_RDONLY|os.O_CREATE, 0666)
	f.Close()
	CheckErrFatal(err)

	Db, err := sql.Open("sqlite3", filepath.Join(Params.DbDir, "db.sqlite"))
	CheckErrFatal(err)

	rsql, err := os.Open("./static/schema.sql")
	CheckErrFatal(err)
	defer rsql.Close()

	sql, err := io.ReadAll(rsql)
	CheckErrFatal(err)

	_, err = Db.Exec(string(sql))
	CheckErrFatal(err)
}

func DbGetIds(ctx context.Context, tbl, idCol, ordCol string, offset, limit int) (ids []string, err error) {
	sql := fmt.Sprintf(`
		SELECT (%s)
		FROM %s
		ORDER BY %s
		LIMIT %d
		OFFSET %d
	`, idCol, tbl, ordCol, offset, limit)

	rs, err := Db.QueryContext(ctx, sql)
	if err != nil {
		return
	}
	defer rs.Close()

	ids = make([]string, 0, 8)
	for rs.Next() {
		var id string
		err = rs.Scan(&id)
		if err != nil {
			return
		}
		ids = append(ids, id)
	}

	return
}

func DbGetSongFlat(ctx context.Context, id string) (*protos.Song, error) {
	sql := `
		SELECT (s.id, s.name, s.album, a.name, s.track)
		FROM songs AS s
		LEFT JOIN albums AS a ON s.album = a.id
		WHERE id = ?
	`

	rs := Db.QueryRowContext(ctx, sql, id)
	s := &protos.Song{}
	err := rs.Scan(&s.Id, &s.Name, &s.Album.Id, &s.Album.Name, &s.Track)
	return s, err
}

func DbGetAlbumFlat(ctx context.Context, id string) (*protos.Album, error) {
	sql := `
		SELECT (id, name)
		FROM albums
		WHERE id = ?
	`

	rs := Db.QueryRowContext(ctx, sql, id)
	a := &protos.Album{}
	err := rs.Scan(&a.Id, &a.Name)
	return a, err
}

func DbGetArtistFlat(ctx context.Context, id string) (*protos.Artist, error) {
	sql := `
		SELECT (id, name)
		FROM artists
		WHERE id = ?
	`

	rs := Db.QueryRowContext(ctx, sql, id)
	a := &protos.Artist{}
	err := rs.Scan(&a.Id, &a.Name)
	return a, err
}

func DbGetConnectedIds(ctx context.Context, tbl, selectId, whereId, id string) (ids []string, err error) {
	sql := fmt.Sprintf(`
		SELECT (%s)
		FROM %s
		WHERE %s = ?
	`, tbl, selectId, whereId)

	rs, err := Db.QueryContext(ctx, sql, id)
	if err != nil {
		return
	}
	defer rs.Close()

	ids = make([]string, 0, 8)
	for rs.Next() {
		var id string
		err = rs.Scan(&id)
		if err != nil {
			return
		}
		ids = append(ids, id)
	}
	return
}

func DbGetSong(ctx context.Context, id string) (*protos.Song, error) {
	s, err := DbGetSongFlat(ctx, id)
	if err != nil {
		return s, err
	}

	aIds, err := DbGetConnectedIds(ctx, "songs_artists", "song_id", "artist_id", id)

	s.Artists = make([]*protos.ArtistInfo, len(aIds))
	for i, aId := range aIds {
		a, err := DbGetArtistFlat(ctx, aId)
		if err != nil {
			return s, err
		}
		s.Artists[i] = &protos.ArtistInfo{
			Id:   a.Id,
			Name: a.Name,
		}
	}

	return s, err
}

func DbGetSongs(ctx context.Context, ids []string) (*protos.Songs, error) {
	ss := protos.Songs{
		Songs: make([]*protos.Song, 0),
	}

	for i := range ids {
		s, err := DbGetSong(ctx, ids[i])
		if err != nil {
			return &ss, err
		}
		ss.Songs = append(ss.Songs, s)
	}

	return &ss, nil
}
